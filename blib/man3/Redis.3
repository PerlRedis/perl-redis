.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.23)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Redis 3"
.TH Redis 3 "2012-09-05" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Redis \- Perl binding for Redis database
.SH "VERSION"
.IX Header "VERSION"
version 1.953
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    ## Defaults to $ENV{REDIS_SERVER} or 127.0.0.1:6379
\&    my $redis = Redis\->new;
\&
\&    my $redis = Redis\->new(server => \*(Aqredis.example.com:8080\*(Aq);
\&
\&    ## Use UNIX domain socket
\&    my $redis = Redis\->new(sock => \*(Aq/path/to/socket\*(Aq);
\&
\&    ## Enable auto\-reconnect
\&    ## Try to reconnect every 500ms up to 60 seconds until success
\&    ## Die if you can\*(Aqt after that
\&    my $redis = Redis\->new(reconnect => 60);
\&
\&    ## Try each 100ms upto 2 seconds (every is in milisecs)
\&    my $redis = Redis\->new(reconnect => 2, every => 100);
\&
\&    ## Disable the automatic utf8 encoding => much more performance
\&    ## !!!! This will be the default after 2.000, see ENCODING below
\&    my $redis = Redis\->new(encoding => undef);
\&
\&    ## Use all the regular Redis commands, they all accept a list of
\&    ## arguments
\&    ## See http://redis.io/commands for full list
\&    $redis\->get(\*(Aqkey\*(Aq);
\&    $redis\->set(\*(Aqkey\*(Aq => \*(Aqvalue\*(Aq);
\&    $redis\->sort(\*(Aqlist\*(Aq, \*(AqDESC\*(Aq);
\&    $redis\->sort(qw{list LIMIT 0 5 ALPHA DESC});
\&
\&    ## Add a coderef argument to run a command in the background
\&    $redis\->sort(qw{list LIMIT 0 5 ALPHA DESC}, sub {
\&      my ($reply, $error) = @_;
\&      die "Oops, got an error: $error\en" if defined $error;
\&      print "$_\en" for @$reply;
\&    });
\&    long_computation();
\&    $redis\->wait_all_responses;
\&
\&    ## Or run a large batch of commands in a pipeline
\&    my %hash = _get_large_batch_of_commands();
\&    $redis\->hset(\*(Aqh\*(Aq, $_, $hash{$_}, sub {}) for keys %hash;
\&    $redis\->wait_all_responses;
\&
\&    ## Publish/Subscribe
\&    $redis\->subscribe(
\&      \*(Aqtopic_1\*(Aq,
\&      \*(Aqtopic_2\*(Aq,
\&      sub {
\&        my ($message, $topic, $subscribed_topic) = @_
\&
\&          ## $subscribed_topic can be different from topic if
\&          ## you use psubscribe() with wildcards
\&      }
\&    );
\&    $redis\->psubscribe(\*(Aqnasdaq.*\*(Aq, sub {...});
\&
\&    ## Blocks and waits for messages, calls subscribe() callbacks
\&    ##  ... forever
\&    my $timeout = 10;
\&    $redis\->wait_for_messages($timeout) while 1;
\&
\&    ##  ... until some condition
\&    my $keep_going = 1; ## other code will set to false to quit
\&    $redis\->wait_for_messages($timeout) while $keep_going;
\&
\&    $redis\->publish(\*(Aqtopic_1\*(Aq, \*(Aqmessage\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pure perl bindings for <http://redis.io/>
.PP
This version supports protocol 2.x (multi-bulk) or later of Redis
available at <https://github.com/antirez/redis/>.
.PP
This documentation lists commands which are exercised in test suite, but
additional commands will work correctly since protocol specifies enough
information to support almost all commands with same piece of code with
a little help of \f(CW\*(C`AUTOLOAD\*(C'\fR.
.SH "PIPELINING"
.IX Header "PIPELINING"
Usually, running a command will wait for a response.  However, if you're
doing large numbers of requests, it can be more efficient to use what Redis
calls \fIpipelining\fR: send multiple commands to Redis without waiting for a
response, then wait for the responses that come in.
.PP
To use pipelining, add a coderef argument as the last argument to a command
method call:
.PP
.Vb 1
\&  $r\->set(\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, sub {});
.Ve
.PP
Pending responses to pipelined commands are processed in a single batch, as
soon as at least one of the following conditions holds:
.IP "\(bu" 4
A non-pipelined (synchronous) command has been sent on the same connection
.IP "\(bu" 4
A pub/sub subscription command (one of \f(CW\*(C`subscribe\*(C'\fR, \f(CW\*(C`unsubscribe\*(C'\fR,
\&\f(CW\*(C`psubscribe\*(C'\fR, or \f(CW\*(C`punsubscribe\*(C'\fR) is about to be sent on the same
connection.
.IP "\(bu" 4
The \*(L"wait_all_responses\*(R" method is called explicitly.
.PP
The coderef you supply to a pipelined command method is invoked once the
response is available.  It takes two arguments, \f(CW$reply\fR and \f(CW$error\fR.  If
\&\f(CW$error\fR is defined, it contains the text of an error reply sent by the
Redis server.  Otherwise, \f(CW$reply\fR is the non-error reply.  For almost all
commands, that means it's \f(CW\*(C`undef\*(C'\fR, or a defined but non-reference scalar,
or an array ref of any of those; but see \*(L"keys\*(R", \*(L"info\*(R", and \*(L"exec\*(R".
.PP
Note the contrast with synchronous commands, which throw an exception on
receipt of an error reply, or return a non-error reply directly.
.PP
The fact that pipelined commands never throw an exception can be
particularly useful for Redis transactions; see \*(L"exec\*(R".
.SH "ENCODING"
.IX Header "ENCODING"
\&\fBThis feature is deprecated and will be removed before 2.000\fR. You
should start testing your code with \f(CW\*(C`encoding => undef\*(C'\fR because
that will be the new default with 2.000.
.PP
Since Redis knows nothing about encoding, we are forcing utf\-8 flag on
all data received from Redis. This change was introduced in 1.2001
version. \fBPlease note\fR that this encoding option severely degrades
performance.
.PP
You can disable this automatic encoding by passing an option to
\&\*(L"new\*(R": \f(CW\*(C`encoding => undef\*(C'\fR.
.PP
This allows us to round-trip utf\-8 encoded characters correctly, but
might be problem if you push binary junk into Redis and expect to get it
back without utf\-8 flag turned on.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
\fInew\fR
.IX Subsection "new"
.PP
.Vb 1
\&    my $r = Redis\->new; # $ENV{REDIS_SERVER} or 127.0.0.1:6379
\&
\&    my $r = Redis\->new( server => \*(Aq192.168.0.1:6379\*(Aq, debug => 0 );
\&    my $r = Redis\->new( server => \*(Aq192.168.0.1:6379\*(Aq, encoding => undef );
\&    my $r = Redis\->new( sock => \*(Aq/path/to/sock\*(Aq );
\&    my $r = Redis\->new( reconnect => 60, every => 5000 );
\&    my $r = Redis\->new( password => \*(Aqboo\*(Aq );
.Ve
.PP
The \f(CW\*(C`server\*(C'\fR parameter specifies the Redis server we should connect
to, via \s-1TCP\s0. Use the '\s-1IP:PORT\s0' format. If no \f(CW\*(C`server\*(C'\fR option is
present, we will attempt to use the \f(CW\*(C`REDIS_SERVER\*(C'\fR environment
variable. If neither of those options are present, it defaults to
\&'127.0.0.1:6379'.
.PP
Alternatively you can use the \f(CW\*(C`sock\*(C'\fR parameter to specify the path
of the \s-1UNIX\s0 domain socket where the Redis server is listening.
.PP
The \f(CW\*(C`REDIS_SERVER\*(C'\fR can be used for \s-1UNIX\s0 domain sockets too. The following formats are supported:
.IP "\(bu" 4
/path/to/sock
.IP "\(bu" 4
unix:/path/to/sock
.IP "\(bu" 4
127.0.0.1:11011
.IP "\(bu" 4
tcp:127.0.0.1:11011
.PP
The \f(CW\*(C`encoding\*(C'\fR parameter speficies the encoding we will use to
decode all the data we receive and encode all the data sent to the redis
server. Due to backwards-compatibility we default to \f(CW\*(C`utf8\*(C'\fR. To
disable all this encoding/decoding, you must use \f(CW\*(C`<encoding =\*(C'\fR undef>>.
\&\fBThis is the recommended option\fR.
.PP
\&\fBWarning\fR: this option has several problems and it is
\&\fBdeprecated\fR. A future version might add other filtering options though.
.PP
The \f(CW\*(C`reconnect\*(C'\fR option enables auto-reconnection mode. If we cannot
connect to the Redis server, or if a network write fails, we enter retry
mode. We will try a new connection every \f(CW\*(C`every\*(C'\fR miliseconds
(1000ms by default), up-to \f(CW\*(C`reconnect\*(C'\fR seconds.
.PP
Be aware that read errors will always thrown an exception, and will not
trigger a retry until the new command is sent.
.PP
If we cannot re-establish a connection after \f(CW\*(C`reconnect\*(C'\fR seconds,
an exception will be thrown.
.PP
If your Redis server requires authentication, you can use the
\&\f(CW\*(C`password\*(C'\fR attribute. After each established connection (at the
start or when reconnecting), the Redis \f(CW\*(C`AUTH\*(C'\fR command will be send
to the server. If the password is wrong, an exception will be thrown and
reconnect will be disabled.
.PP
The \f(CW\*(C`debug\*(C'\fR parameter enables debug information to \s-1STDERR\s0,
including all interactions with the server. You can also enable debug
with the \f(CW\*(C`REDIS_DEBUG\*(C'\fR environment variable.
.SS "Connection Handling"
.IX Subsection "Connection Handling"
\fIquit\fR
.IX Subsection "quit"
.PP
.Vb 1
\&  $r\->quit;
.Ve
.PP
Closes the connection to the server. The \f(CW\*(C`quit\*(C'\fR method does not support
pipelined operation.
.PP
\fIping\fR
.IX Subsection "ping"
.PP
.Vb 1
\&  $r\->ping || die "no server?";
.Ve
.PP
The \f(CW\*(C`ping\*(C'\fR method does not support pipelined operation.
.SS "Pipeline management"
.IX Subsection "Pipeline management"
\fIwait_all_responses\fR
.IX Subsection "wait_all_responses"
.PP
Waits until all pending pipelined responses have been received, and invokes
the pipeline callback for each one.  See \*(L"\s-1PIPELINING\s0\*(R".
.SS "Transaction-handling commands"
.IX Subsection "Transaction-handling commands"
\&\fBWarning:\fR the behaviour of these commands when combined with
pipelining is still under discussion, and you should \fB\s-1NOT\s0\fR use them at
the same time just now.
.PP
You can follow the discussion to see the open issues with this <https://github.com/melo/perl-redis/issues/17>.
.PP
\fImulti\fR
.IX Subsection "multi"
.PP
.Vb 1
\&  $r\->multi;
.Ve
.PP
\fIdiscard\fR
.IX Subsection "discard"
.PP
.Vb 1
\&  $r\->discard;
.Ve
.PP
\fIexec\fR
.IX Subsection "exec"
.PP
.Vb 1
\&  my @individual_replies = $r\->exec;
.Ve
.PP
\&\f(CW\*(C`exec\*(C'\fR has special behaviour when run in a pipeline: the \f(CW$reply\fR argument
to the pipeline callback is an array ref whose elements are themselves
\&\f(CW\*(C`[$reply, $error]\*(C'\fR pairs.  This means that you can accurately detect errors
yielded by any command in the transaction, and without any exceptions being
thrown.
.SS "Commands operating on string values"
.IX Subsection "Commands operating on string values"
\fIset\fR
.IX Subsection "set"
.PP
.Vb 1
\&  $r\->set( foo => \*(Aqbar\*(Aq );
\&
\&  $r\->setnx( foo => 42 );
.Ve
.PP
\fIget\fR
.IX Subsection "get"
.PP
.Vb 1
\&  my $value = $r\->get( \*(Aqfoo\*(Aq );
.Ve
.PP
\fImget\fR
.IX Subsection "mget"
.PP
.Vb 1
\&  my @values = $r\->mget( \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq );
.Ve
.PP
\fIincr\fR
.IX Subsection "incr"
.PP
.Vb 1
\&  $r\->incr(\*(Aqcounter\*(Aq);
\&
\&  $r\->incrby(\*(Aqtripplets\*(Aq, 3);
.Ve
.PP
\fIdecr\fR
.IX Subsection "decr"
.PP
.Vb 1
\&  $r\->decr(\*(Aqcounter\*(Aq);
\&
\&  $r\->decrby(\*(Aqtripplets\*(Aq, 3);
.Ve
.PP
\fIexists\fR
.IX Subsection "exists"
.PP
.Vb 1
\&  $r\->exists( \*(Aqkey\*(Aq ) && print "got key!";
.Ve
.PP
\fIdel\fR
.IX Subsection "del"
.PP
.Vb 1
\&  $r\->del( \*(Aqkey\*(Aq ) || warn "key doesn\*(Aqt exist";
.Ve
.PP
\fItype\fR
.IX Subsection "type"
.PP
.Vb 1
\&  $r\->type( \*(Aqkey\*(Aq ); # = string
.Ve
.SS "Commands operating on the key space"
.IX Subsection "Commands operating on the key space"
\fIkeys\fR
.IX Subsection "keys"
.PP
.Vb 2
\&  my @keys = $r\->keys( \*(Aq*glob_pattern*\*(Aq );
\&  my $keys = $r\->keys( \*(Aq*glob_pattern*\*(Aq ); # count of matching keys
.Ve
.PP
Note that synchronous \f(CW\*(C`keys\*(C'\fR calls in a scalar context return the number of
matching keys (not an array ref of matching keys as you might expect).  This
does not apply in pipelined mode: assuming the server returns a list of
keys, as expected, it is always passed to the pipeline callback as an array
ref.
.PP
\fIrandomkey\fR
.IX Subsection "randomkey"
.PP
.Vb 1
\&  my $key = $r\->randomkey;
.Ve
.PP
\fIrename\fR
.IX Subsection "rename"
.PP
.Vb 1
\&  my $ok = $r\->rename( \*(Aqold\-key\*(Aq, \*(Aqnew\-key\*(Aq, $new );
.Ve
.PP
\fIdbsize\fR
.IX Subsection "dbsize"
.PP
.Vb 1
\&  my $nr_keys = $r\->dbsize;
.Ve
.SS "Commands operating on lists"
.IX Subsection "Commands operating on lists"
See also Redis::List for tie interface.
.PP
\fIrpush\fR
.IX Subsection "rpush"
.PP
.Vb 1
\&  $r\->rpush( $key, $value );
.Ve
.PP
\fIlpush\fR
.IX Subsection "lpush"
.PP
.Vb 1
\&  $r\->lpush( $key, $value );
.Ve
.PP
\fIllen\fR
.IX Subsection "llen"
.PP
.Vb 1
\&  $r\->llen( $key );
.Ve
.PP
\fIlrange\fR
.IX Subsection "lrange"
.PP
.Vb 1
\&  my @list = $r\->lrange( $key, $start, $end );
.Ve
.PP
\fIltrim\fR
.IX Subsection "ltrim"
.PP
.Vb 1
\&  my $ok = $r\->ltrim( $key, $start, $end );
.Ve
.PP
\fIlindex\fR
.IX Subsection "lindex"
.PP
.Vb 1
\&  $r\->lindex( $key, $index );
.Ve
.PP
\fIlset\fR
.IX Subsection "lset"
.PP
.Vb 1
\&  $r\->lset( $key, $index, $value );
.Ve
.PP
\fIlrem\fR
.IX Subsection "lrem"
.PP
.Vb 1
\&  my $modified_count = $r\->lrem( $key, $count, $value );
.Ve
.PP
\fIlpop\fR
.IX Subsection "lpop"
.PP
.Vb 1
\&  my $value = $r\->lpop( $key );
.Ve
.PP
\fIrpop\fR
.IX Subsection "rpop"
.PP
.Vb 1
\&  my $value = $r\->rpop( $key );
.Ve
.SS "Commands operating on sets"
.IX Subsection "Commands operating on sets"
\fIsadd\fR
.IX Subsection "sadd"
.PP
.Vb 1
\&  my $ok = $r\->sadd( $key, $member );
.Ve
.PP
\fIscard\fR
.IX Subsection "scard"
.PP
.Vb 1
\&  my $n_elements = $r\->scard( $key );
.Ve
.PP
\fIsdiff\fR
.IX Subsection "sdiff"
.PP
.Vb 2
\&  my @elements = $r\->sdiff( $key1, $key2, ... );
\&  my $elements = $r\->sdiff( $key1, $key2, ... ); # ARRAY ref
.Ve
.PP
\fIsdiffstore\fR
.IX Subsection "sdiffstore"
.PP
.Vb 1
\&  my $ok = $r\->sdiffstore( $dstkey, $key1, $key2, ... );
.Ve
.PP
\fIsinter\fR
.IX Subsection "sinter"
.PP
.Vb 2
\&  my @elements = $r\->sinter( $key1, $key2, ... );
\&  my $elements = $r\->sinter( $key1, $key2, ... ); # ARRAY ref
.Ve
.PP
\fIsinterstore\fR
.IX Subsection "sinterstore"
.PP
.Vb 1
\&  my $ok = $r\->sinterstore( $dstkey, $key1, $key2, ... );
.Ve
.PP
\fIsismember\fR
.IX Subsection "sismember"
.PP
.Vb 1
\&  my $bool = $r\->sismember( $key, $member );
.Ve
.PP
\fIsmembers\fR
.IX Subsection "smembers"
.PP
.Vb 2
\&  my @elements = $r\->smembers( $key );
\&  my $elements = $r\->smembers( $key ); # ARRAY ref
.Ve
.PP
\fIsmove\fR
.IX Subsection "smove"
.PP
.Vb 1
\&  my $ok = $r\->smove( $srckey, $dstkey, $element );
.Ve
.PP
\fIspop\fR
.IX Subsection "spop"
.PP
.Vb 1
\&  my $element = $r\->spop( $key );
.Ve
.PP
\fIspop\fR
.IX Subsection "spop"
.PP
.Vb 1
\&  my $element = $r\->srandmember( $key );
.Ve
.PP
\fIsrem\fR
.IX Subsection "srem"
.PP
.Vb 1
\&  $r\->srem( $key, $member );
.Ve
.PP
\fIsunion\fR
.IX Subsection "sunion"
.PP
.Vb 2
\&  my @elements = $r\->sunion( $key1, $key2, ... );
\&  my $elements = $r\->sunion( $key1, $key2, ... ); # ARRAY ref
.Ve
.PP
\fIsunionstore\fR
.IX Subsection "sunionstore"
.PP
.Vb 1
\&  my $ok = $r\->sunionstore( $dstkey, $key1, $key2, ... );
.Ve
.SS "Sorting"
.IX Subsection "Sorting"
\fIsort\fR
.IX Subsection "sort"
.PP
.Vb 1
\&  $r\->sort("key BY pattern LIMIT start end GET pattern ASC|DESC ALPHA\*(Aq);
.Ve
.SS "Publish/Subscribe commands"
.IX Subsection "Publish/Subscribe commands"
When one of \*(L"subscribe\*(R" or \*(L"psubscribe\*(R" is used, the Redis object
will enter \fIPubSub\fR mode. When in \fIPubSub\fR mode only commands in this
section, plus \*(L"quit\*(R", will be accepted.
.PP
If you plan on using PubSub and other Redis functions, you should
use two Redis objects, one dedicated to PubSub and the other for
regular commands.
.PP
All Pub/Sub commands receive a callback as the last parameter. This callback receives three arguments:
.IP "\(bu" 4
The published message.
.IP "\(bu" 4
The topic over which the message was sent.
.IP "\(bu" 4
The subscribed topic that matched the topic for the message. With
\&\*(L"subscribe\*(R" these last two are the same, always. But with
\&\*(L"psubscribe\*(R", this parameter tells you the pattern that matched.
.PP
See the Pub/Sub notes <http://redis.io/topics/pubsub> for more
information about the messages you will receive on your callbacks after
each \*(L"subscribe\*(R", \*(L"unsubscribe\*(R", \*(L"psubscribe\*(R" and
\&\*(L"punsubscribe\*(R".
.PP
\fIpublish\fR
.IX Subsection "publish"
.PP
.Vb 1
\&  $r\->publish($topic, $message);
.Ve
.PP
Publishes the \f(CW$message\fR to the \f(CW$topic\fR.
.PP
\fIsubscribe\fR
.IX Subsection "subscribe"
.PP
.Vb 7
\&  $r\->subscribe(
\&      @topics_to_subscribe_to,
\&      sub {
\&        my ($message, $topic, $subscribed_topic) = @_;
\&        ...
\&      },
\&  );
.Ve
.PP
Subscribe one or more topics. Messages published into one of them will
be received by Redis, and the specificed callback will be executed.
.PP
\fIunsubscribe\fR
.IX Subsection "unsubscribe"
.PP
.Vb 1
\&  $r\->unsubscribe(@topic_list, sub { my ($m, $t, $s) = @_; ... });
.Ve
.PP
Stops receiving messages for all the topics in \f(CW@topic_list\fR.
.PP
\fIpsubscribe\fR
.IX Subsection "psubscribe"
.PP
.Vb 2
\&  my @topic_matches = (\*(Aqprefix1.*\*(Aq, \*(Aqprefix2.*\*(Aq);
\&  $r\->psubscribe(@topic_matches, sub { my ($m, $t, $s) = @_; ... });
.Ve
.PP
Subscribes a pattern of topics. All messages to topics that match the
pattern will be delivered to the callback.
.PP
\fIpunsubscribe\fR
.IX Subsection "punsubscribe"
.PP
.Vb 2
\&  my @topic_matches = (\*(Aqprefix1.*\*(Aq, \*(Aqprefix2.*\*(Aq);
\&  $r\->punsubscribe(@topic_matches, sub { my ($m, $t, $s) = @_; ... });
.Ve
.PP
Stops receiving messages for all the topics pattern matches in \f(CW@topic_list\fR.
.PP
\fIis_subscriber\fR
.IX Subsection "is_subscriber"
.PP
.Vb 1
\&  if ($r\->is_subscriber) { say "We are in Pub/Sub mode!" }
.Ve
.PP
Returns true if we are in \fIPub/Sub\fR mode.
.PP
\fIwait_for_messages\fR
.IX Subsection "wait_for_messages"
.PP
.Vb 3
\&  my $keep_going = 1; ## Set to false somewhere to leave the loop
\&  my $timeout = 5;
\&  $r\->wait_for_messages($timeout) while $keep_going;
.Ve
.PP
Blocks, waits for incoming messages and delivers them to the appropriate callbacks.
.PP
Requires a single parameter, the number of seconds to wait for messages.
Use 0 to wait for ever. If a positive non-zero value is used, it will
return after that ammount of seconds without a single notification.
.PP
Please note that the timeout is not a commitement to return control to
the caller at most each \f(CW\*(C`timeout\*(C'\fR seconds, but more a idle timeout,
were control will return to the caller if Redis is idle (as in no
messages were received during the timeout period) for more than
\&\f(CW\*(C`timeout\*(C'\fR seconds.
.PP
The \*(L"wait_for_messages\*(R" call returns the number of messages processed
during the run.
.SS "Persistence control commands"
.IX Subsection "Persistence control commands"
\fIsave\fR
.IX Subsection "save"
.PP
.Vb 1
\&  $r\->save;
.Ve
.PP
\fIbgsave\fR
.IX Subsection "bgsave"
.PP
.Vb 1
\&  $r\->bgsave;
.Ve
.PP
\fIlastsave\fR
.IX Subsection "lastsave"
.PP
.Vb 1
\&  $r\->lastsave;
.Ve
.SS "Remote server control commands"
.IX Subsection "Remote server control commands"
\fIinfo\fR
.IX Subsection "info"
.PP
.Vb 1
\&  my $info_hash = $r\->info;
.Ve
.PP
The \f(CW\*(C`info\*(C'\fR method is unique in that it decodes the server's response into a
hashref, if possible.  This decoding happens in both synchronous and
pipelined modes.
.PP
\fIshutdown\fR
.IX Subsection "shutdown"
.PP
.Vb 1
\&  $r\->shutdown;
.Ve
.PP
The \f(CW\*(C`shutdown\*(C'\fR method does not support pipelined operation.
.SS "Multiple databases handling commands"
.IX Subsection "Multiple databases handling commands"
\fIselect\fR
.IX Subsection "select"
.PP
.Vb 1
\&  $r\->select( $dbindex ); # 0 for new clients
.Ve
.PP
\fImove\fR
.IX Subsection "move"
.PP
.Vb 1
\&  $r\->move( $key, $dbindex );
.Ve
.PP
\fIflushdb\fR
.IX Subsection "flushdb"
.PP
.Vb 1
\&  $r\->flushdb;
.Ve
.PP
\fIflushall\fR
.IX Subsection "flushall"
.PP
.Vb 1
\&  $r\->flushall;
.Ve
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Perldoc"
.IX Subsection "Perldoc"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&  perldoc Redis
.Ve
.SS "Websites"
.IX Subsection "Websites"
The following websites have more information about this module, and may be of help to you. As always,
in addition to those websites please use your favorite search engine to discover more resources.
.IP "\(bu" 4
\&\s-1CPAN\s0 Testers
.Sp
The \s-1CPAN\s0 Testers is a network of smokers who run automated tests on uploaded \s-1CPAN\s0 distributions.
.Sp
<http://www.cpantesters.org/distro/R/Redis>
.IP "\(bu" 4
\&\s-1CPAN\s0 Testers Matrix
.Sp
The \s-1CPAN\s0 Testers Matrix is a website that provides a visual overview of the test results for a distribution on various Perls/platforms.
.Sp
<http://matrix.cpantesters.org/?dist=Redis>
.IP "\(bu" 4
\&\s-1CPAN\s0 Testers Dependencies
.Sp
The \s-1CPAN\s0 Testers Dependencies is a website that shows a chart of the test results of all dependencies for a distribution.
.Sp
<http://deps.cpantesters.org/?module=Redis>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
The \s-1CPAN\s0 Ratings is a website that allows community ratings and reviews of Perl modules.
.Sp
<http://cpanratings.perl.org/d/Redis>
.SS "Email"
.IX Subsection "Email"
You can email the author of this module at \f(CW\*(C`MELO at cpan.org\*(C'\fR asking for help with any problems you have.
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs or feature requests by email to \f(CW\*(C`bug\-redis at rt.cpan.org\*(C'\fR, or through
the web interface at <http://rt.cpan.org/Public/Dist/Display.html?Name=Redis>. You will be automatically notified of any
progress on the request by the system.
.SS "Source Code"
.IX Subsection "Source Code"
<https://github.com/melo/perl\-redis>
.PP
.Vb 1
\&  git clone https://github.com/melo/perl\-redis.git
.Ve
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
The following persons contributed to this project (alphabetical order):
.IP "\(bu" 4
Aaron Crane (pipelining and \s-1AUTOLOAD\s0 caching support)
.IP "\(bu" 4
Dirk Vleugels
.IP "\(bu" 4
Flavio Poletti
.IP "\(bu" 4
Jeremy Zawodny
.IP "\(bu" 4
sunnavy at bestpractical.com
.IP "\(bu" 4
Thiago Berlitz Rondon
.IP "\(bu" 4
Ulrich Habel
.SH "AUTHOR"
.IX Header "AUTHOR"
Pedro Melo <melo@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2012 by Pedro Melo.
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Artistic License 2.0 (GPL Compatible)
.Ve
